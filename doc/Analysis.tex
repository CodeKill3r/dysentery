\documentclass[11pt]{article}

\usepackage[english]{babel}
\usepackage{courier}
\usepackage{graphicx}
\usepackage[bottom]{footmisc}
\usepackage{bytefield}
\usepackage{hyperref}
\usepackage{bookmark}

\title{DJ Link Packet Analysis}
\author{James Elliott\\Deep Symmetry, LLC}

\begin{document}

\maketitle

\abstract{The protocol used by Pioneer professional DJ equipment to
  communicate and coordinate performances can be monitored to provide
  useful information for synchronizing other software, such as light
  shows and sequencers. By creating a ``virtual CDJ'' that sends
  appropriate packets to the network, other devices can be induced to
  send packets containing even more useful information about their
  state. This article documents what has been learned so far about the
  protocol, and how to accomplish these tasks.}

\pagestyle{headings}

\section{Mixer Startup}

When the mixer starts up, after it obtains an IP address (or gives up
on doing that and self-assigns an address), it sends out what look
like a series of packets\footnote{The packet capture described in this
  analysis can be found at
  \url{https://github.com/brunchboy/dysentery/raw/master/doc/assets/powerup.pcapng}}
simply announcing its existence to UDP port 50000 on the broadcast
address of the local network.

\begin{figure}
  \begin{bytefield}[bitwidth=1.5em]{16}
    \bitheader{0-15} \\
    \begin{rightwordgroup}{Name}
      \begin{leftwordgroup}{Header}
        \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a} {\tt 4f}
          {\tt 4c} {\tt \textbf{0a}} {\tt 00}}
        & \bitbox[lrt]{4}{}
      \end{leftwordgroup} \\
      \wordbox[lrb]{1}{Device Name (padded with {\tt 00})} 
    \end{rightwordgroup} \\
    \bitboxes*{1}{{\tt 01} {\tt 02} {\tt 00} {\tt 25} {\tt 02}} \\
  \end{bytefield}
  \caption{Initial announcement packets from Mixer}
  \label{fig:mixerInitial}
\end{figure}

These have a data length\footnote{Values within packets are shown in
  hexadecimal, while packet lengths and byte offsets are discussed in
  decimal.} of 37 bytes, appear roughly every 300 milliseconds, and
have the content shown in Figure~\ref{fig:mixerInitial}.

The tenth byte (inside what is labeled the header) is bolded because
its value changes in the different types of packets which follow.

After about three of these packets are sent, another series of three
begins. It is not clear what purpose these packets serve, because they
are not yet asserting ownership of any device number; perhaps they are
used when CDJs are powering up as part of the mechanism the mixer can
use to tell them which device number to use based on which network
port they are connected to?

\begin{figure}
  \begin{bytefield}[bitwidth=1.5em]{16}
    \bitheader{0-15} \\
    \begin{rightwordgroup}{Name}
      \begin{leftwordgroup}{Header}
        \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a} {\tt 4f}
          {\tt 4c} {\tt \textbf{00}} {\tt 00}}
        & \bitbox[lrt]{4}{}
      \end{leftwordgroup} \\
      \wordbox[lrb]{1}{Device Name (padded with {\tt 00})} 
    \end{rightwordgroup} \\
    \bitboxes*{1}{{\tt 01} {\tt 02} {\tt 00} {\tt 2c} {$N$} {\tt 02}} &
    \bitbox{6}{MAC address} \\
  \end{bytefield}
  \caption{First-stage Mixer device number assignment packets}
  \label{fig:mixerStage1}
\end{figure}

In any case, these three packets have a data length of 44 bytes, are
again sent to UDP port 50000 on the local network broadcast address,
at roughly 300 millisecond intervals, and have the content shown in
Figure~\ref{fig:mixerStage1}.

The value $N$ at byte~36 is 1, 2, or 3, depending on whether this
is the first, second, or third time the packet is sent.

After these comes another series of three numbered packets. These
appear to be claiming the device number for a particular device, as
well as announcing the IP address at which it can be found. They have
a data length of 50 bytes, and are again sent to UDP port 50000 on the
local network broadcast address, at roughly 300 millisecond intervals,
with the content shown in Figure~\ref{fig:mixerStage2}.

\begin{figure}[ht]
  \begin{bytefield}[bitwidth=1.5em]{16}
    \bitheader{0-15} \\
    \begin{rightwordgroup}{Name}
      \begin{leftwordgroup}{Header}
        \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a} {\tt 4f}
          {\tt 4c} {\tt \textbf{02}} {\tt 00}}
        & \bitbox[lrt]{4}{}
      \end{leftwordgroup} \\
      \wordbox[lrb]{1}{Device Name (padded with {\tt 00})} 
    \end{rightwordgroup} \\
    \bitboxes*{1}{{\tt 01} {\tt 02} {\tt 00} {\tt 32}} &
    \bitbox{4}{IP address} & \bitbox{6}{MAC address} &
    \bitbox{1}{$D$} & \bitbox{1}{$N$} \\
    \bitboxes*{1}{{\tt 02} {\tt 01}} \\
  \end{bytefield}
  \caption{Second-stage Mixer device number assignment packets}
  \label{fig:mixerStage2}
\end{figure}

I identify these as claiming/identifying the device number because the
value $D$ at byte~46 is the same as the device number that the
mixer uses to identify itself ({\tt 0x21}) and the same is true for the
corresponding packets seen from the CDJs (they use device numbers 2
and 3, as they are connected to those ports/channels on the mixer).

As with the previous series of three packets, the value $N$ at
byte~47 takes on the values 1, 2, and 3 in the three packets.

These are followed by another three packets, perhaps the last stage of
claiming the device number, again at 300 millisecond intervals, to the
same port 50000. These shorter packets have 38 bytes of data and the
content shown in Figure~\ref{fig:mixerStage3}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.5em]{16}
    \bitheader{0-15} \\
    \begin{rightwordgroup}{Name}
      \begin{leftwordgroup}{Header}
        \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a} {\tt 4f}
          {\tt 4c} {\tt \textbf{04}} {\tt 00}}
        & \bitbox[lrt]{4}{}
      \end{leftwordgroup} \\
      \wordbox[lrb]{1}{Device Name (padded with {\tt 00})} 
    \end{rightwordgroup} \\
    \bitboxes*{1}{{\tt 01} {\tt 02} {\tt 00} {\tt 26}} &
    \bitbox{1}{$D$} & \bitbox{1}{$N$} \\
  \end{bytefield}
  \caption{Final-stage Mixer device number assignment packets}
  \label{fig:mixerStage3}
\end{figure}

As before the value $D$ at byte~36 is the same as the device
number that the mixer uses to identify itself ({\tt 0x21}) and
$N$ at byte~37 takes on the values 1, 2, and 3 in the three
packets.

Once those are sent, the mixer seems to settle down and send what
looks like a keep-alive packet to retain presence on the network and
ownership of its device number, at a less frequent interval. These
packets are 54 bytes long, again sent to port 50000 on the local
network broadcast address, roughly every second and a half. They have
the content shown in Figure~\ref{fig:mixerKeepalive}.

\begin{figure}[ht]
  \begin{bytefield}[bitwidth=1.5em]{16}
    \bitheader{0-15} \\
    \begin{rightwordgroup}{Name}
      \begin{leftwordgroup}{Header}
        \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a} {\tt 4f}
          {\tt 4c} {\tt \textbf{06}} {\tt 00}}
        & \bitbox[lrt]{4}{}
      \end{leftwordgroup} \\
      \wordbox[lrb]{1}{Device Name (padded with {\tt 00})} 
    \end{rightwordgroup} \\
    \bitboxes*{1}{{\tt 01} {\tt 02} {\tt 00} {\tt 36}} &
    \bitbox{1}{$D$} & \bitbox{1}{\tt 02} &
    \bitbox{6}{MAC address} & \bitbox{4}{IP address} \\
    \bitboxes*{1}{{\tt 01} {\tt 00} {\tt 00} {\tt 00} {\tt 02} {\tt 00}} \\
  \end{bytefield}
  \caption{Mixer keep-alive packets}
  \label{fig:mixerKeepalive}
\end{figure}

\section{CDJ Startup}

When a CDJ starts up the procedure and packets are nearly identical,
with groups of three packets sent at 300 millisecond intervals to port
50000 of the local network broadcast address. The only difference
between Figure~\ref{fig:cdjInitial} and Figure~\ref{fig:mixerInitial}
is the final byte, which is {\tt 0x01} for the CDJ, and was {\tt 0x02}
for the mixer.

\begin{figure}[ht]
  \begin{bytefield}[bitwidth=1.5em]{16}
    \bitheader{0-15} \\
    \begin{rightwordgroup}{Name}
      \begin{leftwordgroup}{Header}
        \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a} {\tt 4f}
          {\tt 4c} {\tt \textbf{0a}} {\tt 00}}
        & \bitbox[lrt]{4}{}
      \end{leftwordgroup} \\
      \wordbox[lrb]{1}{Device Name (padded with {\tt 00})} 
    \end{rightwordgroup} \\
    \bitboxes*{1}{{\tt 01} {\tt 02} {\tt 00} {\tt 25} {\tt 01}} \\
  \end{bytefield}
  \caption{Initial announcement packets from CDJ}
  \label{fig:cdjInitial}
\end{figure}

Similarly, the next series of three packets from the CDJ are nearly
identical to those from the mixer. The only difference between
Figure~\ref{fig:cdjStage1} and Figure~\ref{fig:mixerStage1} is byte~37
(immediately after the packet counter $N$), which again is {\tt 0x01}
for the CDJ, and was {\tt 0x02} for the mixer.

\begin{figure}
  \begin{bytefield}[bitwidth=1.5em]{16}
    \bitheader{0-15} \\
    \begin{rightwordgroup}{Name}
      \begin{leftwordgroup}{Header}
        \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a}
          {\tt 4f} {\tt 4c} {\tt \textbf{00}} {\tt 00}}
        & \bitbox[lrt]{4}{}
      \end{leftwordgroup} \\
      \wordbox[lrb]{1}{Device Name (padded with {\tt 00})} 
    \end{rightwordgroup} \\
    \bitboxes*{1}{{\tt 01} {\tt 02} {\tt 00} {\tt 2c} {$N$} {\tt 01}} &
    \bitbox{6}{MAC address} \\
  \end{bytefield}
  \caption{First-stage CDJ device number assignment packets}
  \label{fig:cdjStage1}
\end{figure}

However it appears that in this capture the CDJ skips the second stage
of claiming a device number, probably because it is configured to be
automatically assigned a device number based on the port of the mixer
to which it is connected, and we cannot see a packet that the mixer
sent it assigning it that device number. Instead, it jumps right to
the end of the third and final stage, sending a single 38-byte packet
with header byte~10 set to {tt 04} (which identified the three packets
of the third stage when the mixer was starting up), with content
identical to Figure~\ref{fig:mixerStage3}.

Even though the value of $N$ is {\tt 01}, this is the only packet
in this series that the CDJ sends. It would probably behave
differently if configured to assign its own device number (behaving
like we saw the mixer behave in claiming its device number).

The CDJ then moves to the keep-alive stage, sending out 54-byte
packets with the content shown in Figure~\ref{fig:cdjKeepalive}.

\begin{figure}[ht]
  \begin{bytefield}[bitwidth=1.5em]{16}
    \bitheader{0-15} \\
    \begin{rightwordgroup}{Name}
      \begin{leftwordgroup}{Header}
        \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a} {\tt 4f}
          {\tt 4c} {\tt \textbf{06}} {\tt 00}}
        & \bitbox[lrt]{4}{}
      \end{leftwordgroup} \\
      \wordbox[lrb]{1}{Device Name (padded with {\tt 00})} 
    \end{rightwordgroup} \\
    \bitboxes*{1}{{\tt 01} {\tt 02} {\tt 00} {\tt 36}} &
    \bitbox{1}{$D$} & \bitbox{1}{\tt 01} &
    \bitbox{6}{MAC address} & \bitbox{4}{IP address} \\
    \bitboxes*{1}{{\tt 01} {\tt 00} {\tt 00} {\tt 00} {\tt 01} {\tt 00}} \\
  \end{bytefield}
  \caption{CDJ keep-alive packets}
  \label{fig:cdjKeepalive}
\end{figure}

As seems to always be the case when comparing mixer and CDJ packets,
the difference between this and Figure~\ref{fig:mixerKeepalive} is
that byte~37 (following the device number $D$) has the value {\tt 01}
rather than {\tt 02}, and the same is true of the second-to-last byte
in each of the packets. (Byte~52 is {\tt 01} in
Figure~\ref{fig:cdjKeepalive} and {\tt 02} in
Figure~\ref{fig:mixerKeepalive}.

\section{Tracking BPM and Beats}
\label{sec:beatPackets}

For some time now,
Afterglow\footnote{\url{https://github.com/brunchboy/afterglow\#afterglow}}
has been able to synchronize its light shows with music being played
on Pioneer equipment by observing packets broadcast by the mixer to
port 50001. Until recently, however, it was not possible to tell which
player was the master, so there was no way to determine the down beat
(the start of each measure). Now that it is possible to to determine
which CDJ is the master player using the packets described in
Section~\ref{sec:virtualCdj}, these beat packets have become far more
useful, and Afterglow will soon be using them to track the down beat
based on the beat number reported by the master player.

To track beats, open a socket and bind it to port 50001. The devices
seem to broadcast two different kinds of packets to this port, a
shorter packet containing 45 bytes of data, and a longer packet
containing 96 bytes. The shorter packets seem to all have identical
content, and do not seem to convey useful information, so we currently
simply ignore them.

The 96-byte packets are sent on each beat, so even the arrival of the
packet is interesting information, it means that the player is
starting a new beat. (CDJs send these packets only when they are
playing \emph{and only for rekordbox-analyzed tracks}. The mixer sends
them all the time, acting as a backup metronome when no other device
is counting beats.) The content of these packets is shown in
Figure~\ref{fig:beatPacket}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt]{16}
    \bitheader{0-15} \\

    \begin{leftwordgroup}{\tiny 0} % 0x00
      \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a} {\tt 4f}
        {\tt 4c} {\tt \textbf{28}}}
      & \bitbox[lrt]{5}{}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 16} % 0x10
      \bitbox[lrb]{15}{Device Name (padded with {\tt 00})} \bitbox{1}{\tt 01}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 32} % 0x20
      \bitbox{1}{\tt 00} & \bitbox{1}{$D$} & \bitboxes*{1}{{\tt 00} {\tt 3c} {\tt 00} {\tt 00} {\tt 01} {\tt 00}
        {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 48} % 0x30
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}
        {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt ff} {\tt ff} {\tt ff} {\tt ff}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 64} % 0x40
      \bitboxes*{1}{{\tt ff} {\tt ff} {\tt ff} {\tt ff} {\tt ff} {\tt ff} {\tt ff} {\tt ff}
        {\tt ff} {\tt ff} {\tt ff} {\tt ff} {\tt ff} {\tt ff} {\tt ff} {\tt ff}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 80} % 0x50
      \bitboxes*{1}{{\tt ff} {\tt ff} {\tt ff} {\tt ff} {\tt 00}} & \bitbox{3}{$Pitch$} &
      \bitboxes*{1}{{\tt 00} {\tt 00}} & \bitbox{2}{$BPM$} & \bitbox{1}{$B_b$} & \bitboxes*{1}{{\tt 00} {\tt 00}} &
      \bitbox{1}{$D$}
    \end{leftwordgroup} \\

  \end{bytefield}
  \caption{Beat packets}
  \label{fig:beatPacket}
\end{figure}

The Device Number in $D$ (bytes~33 and 95) is the Player Number as
displayed on the CDJ itself, or 33 for the mixer, or another value for
a computer running rekordbox.

The player's current pitch adjustment\footnote{The mixer always
  reports a pitch of $+0\%$.} can be found in bytes~85--87, labeled
$Pitch$. It represents a three-byte pitch adjustment percentage, where
{\tt 0x100000} represents no adjustment ($0\%$), {\tt 0x000000}
represents slowing all the way to a complete stop ($-100\%$, reachable
only in Wide tempo mode), and {\tt 0x200000} represents playing at
double speed ($+100\%$).

The pitch adjustment percentage represented by $Pitch$ is calculated
as follows:

\begin{displaymath}
  100 \times
  \frac{(byte[85] \times 65536 + byte[86]  \times 256 + byte[87]) - 1048576}{1048576}
\end{displaymath}

The current BPM of the track playing on the device\footnote{The mixer
  passes along the BPM of the master player.} can be found at bytes~90--91
(labeled $BPM$). It is a two-byte integer representing one hundred
times the current track BPM. So, the current track BPM value to two
decimal places can be calculated as:

\[ \frac{byte[90] \times 256 + byte[91]}{100} \]

In order to obtain the actual playing BPM (the value shown in the BPM
display), this value must be multiplied by the current pitch
adjustment. Since calculating the effective BPM reported by a CDJ is a
common operation, here a simplified equation that results in the
effective BPM to two decimal places, by combinining the $BPM$ and
$Pitch$ values:\footnote{Since the mixer always reports a pitch
  adjustment of $+0\%$, its $BPM$ value can be used directly without
  this additional step.}

\[ \frac{(byte[90] \times 256 + byte[91]) \times (byte[85] \times 65536 + byte[86]  \times 256 + byte[87])}
   {104857600} \]

The counter $B_b$ at byte~92 counts out the beat within each bar,
cycling $1\to2\to3\to4$ repeatedly, and can be used to identify the
down beat if it is coming from the master player.

\section{Creating a Virtual CDJ}
\label{sec:virtualCdj}

Although some useful information can be obtained simply by watching
broadcast traffic on a network containing Pioneer gear, in order to
get important details it is necessary to cause the gear to send you
information directly. This can be done by simulating a ``Virtual
CDJ''.\footnote{Thanks are due to Diogo Santos for discovering the
  trick of creating a virtual CDJ in order to receive detailed status
  information from other devices.}

To do this, bind a UDP server socket to port 50002 on the network
interface on which you are receiving DJ-Link traffic, and start
sending keep-alive packets to port 50000 on the broadcast address as
if you were a CDJ. Follow the structure shown in
Figure~\ref{fig:cdjKeepalive}, but use the actual MAC and IP addresses
of the network interface on which you are receiving DJ-Link traffic,
so the devices can see how to reach you.

You can use a value like 5 for $D$ (the device/player number) so
as not to conflict with any actual players you have on the network,
and any name you would like. As long as you are sending these packets
roughly every 1.5 seconds, the other players and mixers will begin
sending packets directly to the socket you have opened on port 50002.

Each device seems to send status packets roughly every 200 milliseconds.

We are just beginning to analyze all the information which can be
gleaned from these packets, but here is what we know so
far.\footnote{Examples of packets discussed in this section can be
  found in the capture at
  \url{https://github.com/brunchboy/dysentery/raw/master/doc/assets/to-virtual.pcapng}}

\subsection{Mixer Status Packets}

Packets from the mixer will have a length of 56 bytes and the content
shown in Figure~\ref{fig:mixerStatus}.

\begin{figure}[h]
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt]{16}
    \bitheader{0-15} \\

    \begin{leftwordgroup}{\tiny 0} % 0x00
      \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a} {\tt 4f}
        {\tt 4c} {\tt \textbf{29}}}
      & \bitbox[lrt]{5}{}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 16} % 0x10
      \bitbox[lrb]{15}{Device Name (padded with {\tt 00})} \bitbox{1}{\tt 01}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 32} % 0x20
      \bitbox{1}{\tt 00} & \bitbox{1}{$D$} & \bitboxes*{1}{{\tt 00} {\tt 14}} &
      \bitbox{1}{$D$} & \bitboxes*{1}{{\tt 00} {\tt 00}} & \bitbox{1}{$F$} &
      \bitboxes*{1}{{\tt 00} {\tt 10} {\tt 00} {\tt 00} {\tt 80} {\tt 00}} & \bitbox{2}{$BPM$}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 48} % 0x30
      \bitboxes*{1}{{\tt 00} {\tt 10} {\tt 00} {\tt 00} {\tt 00} {\tt 09}} &
      \bitbox{1}{$X$} & \bitbox{1}{$B_b$} & \bitbox[]{8}{}
    \end{leftwordgroup} \\
  \end{bytefield}
  \caption{Mixer status packets}
  \label{fig:mixerStatus}
\end{figure}

Packets coming from a DJM-2000 nexus connected as the only mixer on
the network contain a value of 33 ({\tt 0x21}) for their Device Number
$D$ (bytes~33 and 36).

The value marked $F$ at byte~39 is evidently a status flag equivalent
to the one shown in Figure~\ref{fig:cdjStateFlags}, although on a
mixer the only two values seen so far are {\tt 0xf0} when it is the
tempo master, and {\tt 0xd0} when it is not. So evidently the mixer
always considers itself to be playing and synced, but never on-air.

There are two places that might contain pitch values, bytes~41--43 and
bytes~50--51, but since they always {\tt 0x100000} (or $+0\%$), we
can't be sure. The current tempo in beats-per-minute identified by the
mixer can be obtained as:

\[ \frac{byte[46] \times 256 + byte[47]}{100} \]

This value is labeled $BPM$ in Figure~\ref{fig:mixerStatus}.
Unfortunately, this BPM seems to only be valid when a
rekordbox-analyzed source is playing; when the mixer is doing its own
beat detection from unanalyzed audio sources, even though it displays
the detected BPM on the mixer itself, and uses that to drive its beat
effects, it does not send that value in these packets.

The current beat number within a bar (1, 2, 3 or 4) is sent in
$byte[55]$, labeled $B_b$. However, the beat number is \emph{not}
synchronized with the master player, and these packets do not arrive
at the same time as the beat started anyway, so this value is not
useful for much. The beat number should be determined, when needed,
from beat packets (described in Section~\ref{sec:beatPackets}) that
are sent by the master player.

The value at $byte[54]$, labeled $X$, has an unknown meaning. It
seems to start out with the value {\tt 0x00}, and then change when a
player starts playing to the value {\tt 0xff}, but it may well do
other things as well.

\subsection{CDJ Status Packets}

Packets from a CDJ will have a length of 212 bytes and the content
shown in Figure~\ref{fig:cdjStatus} for nexus players. Older players
send 208-byte packets with slightly less information. Newer firmware
and Nexus 2 players send packets that are 284 or 292~bytes long.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt]{16}
    \bitheader{0-15} \\

    \begin{leftwordgroup}{\tiny 0} % 0x00
      \bitboxes*{1}{{\tt 51} {\tt 73} {\tt 70} {\tt 74} {\tt 31} {\tt 57} {\tt 6d} {\tt 4a} {\tt 4f}
        {\tt 4c} {\tt \textbf{0a}}}
      & \bitbox[lrt]{5}{}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 16} % 0x10
      \bitbox[lrb]{15}{Device Name (padded with {\tt 00})} \bitbox{1}{\tt 01}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 32} % 0x20
      \bitbox{1}{\tt 03} & \bitbox{1}{$D$} & \bitboxes*{1}{{\tt 00} {\tt b0}} &
      \bitbox{1}{$D$} & \bitboxes*{1}{{\tt 00} {\tt 01}} & \bitbox{1}{$A$} &
      \bitbox{1}{$D_r$} & \bitbox{1}{$S_r$} & \bitbox{1}{$t_r$} & \bitbox{1}{\tt 00} &
      \bitbox{4}{$rekordbox$}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 48} % 0x30
      \bitboxes*{1}{{\tt 00} {\tt 00}} \bitbox{2}{$Track$} \bitboxes*{1}{{\tt 00} {\tt 00} {$t_2$} {$t_3$}
        {\tt 00} {\tt 00} {$t_4$} {$t_5$} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 64} % 0x40
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {$t_6$} {$t_7$}
        {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 80} % 0x50
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}
        {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 96} % 0x60
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}
        {\tt 01} {\tt 00} {$U_a$} {\tt 04} {\tt 00} {\tt 00} {\tt 00} {$U_l$}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 112} % 0x70
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 04} {\tt 00}} & \bitbox{1}{$U_g$} & \bitboxes*{1}{{\tt 00} {\tt 00}
        {\tt 01} {\tt 00} {\tt 00}} & \bitbox{1}{$P_1$} & \bitbox{4}{$Firmware$}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 128} % 0x80
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}} & \bitbox{2}{$Sync_n$} &
      \bitbox{1}{\tt 00} & \bitbox{1}{$F$} & \bitbox{1}{\tt ff} &
      \bitbox{1}{$P_2$} & \bitbox{1}{\tt 00} & \bitbox{3}{$Pitch_1$}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 144} % 0x90
      \bitbox{2}{$l_1$} & \bitbox{2}{$BPM$} & \bitboxes*{1}{{\tt 7f} {\tt ff} {\tt ff} {\tt ff} {\tt 00}} &
      \bitbox{3}{$Pitch_2$} & \bitbox{1}{\tt 00} & \bitbox{1}{$P_3$} & \bitbox{1}{\tt 00} & \bitbox{1}{\tt ff}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 160} % 0xa0
      \bitbox{4}{$Beat$} & \bitbox{2}{$Cue$} & \bitbox{1}{$B_b$} &
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 176} % 0xb0
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 10} {\tt 00}
        {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 192} % 0xc0
      \bitbox{1}{\tt 00} & \bitbox{3}{$Pitch_3$} & \bitbox{1}{\tt 00} & \bitbox{3}{$Pitch_4$} & 
      \bitbox{4}{$Packet$} & \bitbox{1}{$nx$} & \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 208} % 0xd0
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00}} & \bitbox[]{12}{}
    \end{leftwordgroup} \\

  \end{bytefield}
  \caption{CDJ status packets}
  \label{fig:cdjStatus}
\end{figure}

The Device Number in $D$ (bytes~33 and 36) is the Player Number as
displayed on the CDJ itself. In the case of this capture, the CDJs
were assigned Player Numbers 2 and 3.

The activity flag $A$ at byte~39 seems to be 0 when the player is
idle, and 1 when it is playing, searching, or loading a track.

When a rekordbox track is loaded, the device holding the rekordbox
database from which the track was loaded is reported in $D_r$ at
byte~40 (if the track was loaded from the local device, this will be
the same as $D$; if it was loaded over the Link, it will be the number
of a different device) When no track is loaded, $D_r$ has the value
{\tt 00}.

Similarly, $S_r$ at byte~41 reports the slot from which the track was
loaded: The value {\tt 00} means no track is loaded, {\tt 01} means
the CD drive, {\tt 02} means the SD slot, and {\tt 03} means the USB
slot. When a track is loaded from a rekordbox collection on a laptop,
$S_r$ has the value {\tt 04}. $t_r$ at byte~42 may be an indicator of
whether the track came from rekordbox: It seems to have the value {\tt
  00} when no track is loaded, {\tt 01} when a rekordbox track is
loaded, and {\tt 05} when a regular audio CD is loaded.

The field $rekordbox$ at bytes~44--47 contains the rekordbox database
ID of the loaded track when a rekordbox track is being played.
Combined with the player number and slot information, this can be used
to request the track metadata as described in
Section~\ref{sec:metadata}. When an audio CD is loaded, this just
contains the track index on the disc.

The track number being played (its position within a playlist or other
scrolling list of tracks, as displayed on the CDJ) can be found at
bytes~50 and 51, labeled $Track$. (It may be a 4-byte value and also
include bytes~48 and 49, but that would seem an unmanageable number of
tracks to search through.)

There are a number of bytes, labeled $t_2$ through $t_7$, whose
purpose is as yet undetermined. They are all zero when there is no
track loaded, but take different values when a track is loaded.
(Actually, there are many other bytes than these which behave like
this, so they will probably be removed from the chart in a future
version of this document.)

Byte~106, labeled $U_a$ (for ``USB activity''), alternates between the
values 4 and 6 when there is USB activity---it may even alternate in
time with the flashing USB indicator LED on the player. Byte~111
($U_l$ for ``USB local'') has the value 4 when there is no USB media
loaded, 0 when USB is loaded, and 2 when the USB Stop button has been
pressed and the USB media is being unmounted.

Byte~117, labeled $U_g$ (for ``USB global''), appears to have the
value 1 whenever USB media is present in any player on the network,
whether or not the Link option is chosen in the other players, and 0
otherwise. I don't know if that is true of other linkable SD media as
well; this needs more investigation.

Byte~123, labeled $P_1$, appears to describe the current play mode.
The values that have been seen so far, and their apparent meanings,
are:
\begin{description}
\item[0] No track is loaded.
\item[3] The player is playing normally.
\item[4] The player is playing a loop.
\item[5] The player is paused anywhere other than the cue point.
\item[6] The player is paused at the cue point.
\item[9] The player is searching forwards or backwards.
\item[17] The player reached the end of the track and stopped.
\end{description}

The $Firmware$ value at bytes~124--127 is an ASCII represenation of the
firmware version running in the player.

The value $Sync_n$ at bytes~134--135 seems to increment whenever the
player syncs to a new tempo master (another player or the mixer). I am
assuming it is just a 2-byte value, because I tried syncing 256 times
and saw the counter expand from byte~135 to include byte~134. It may
actually be a 4-byte value and also involve bytes~132 and 133, but I
wasn't going to try changing sync 65,536 times or more to find out.
Perhaps we could write software to test that someday by forcing tempo
master changes.

Byte~137, labeled $F$, is a bit field containing some very useful
state flags, detailed in Figure~\ref{fig:cdjStateFlags}.\footnote{We
  have not yet seen any other values for bits 0, 1, 2, or 7 in $F$, so
  we're unsure if they also carry meaning. If you ever find different
  values for them, please let us know by filing an Issue at
  \url{https://github.com/brunchboy/dysentery/issues}} It seems to
only be available on nexus players, and others always send 0 for this
byte?

\begin{figure}
  \begin{bytefield}[endianness=big,bitwidth=4em]{8}
    \bitheader{0-7} \\
    \bitbox{1}{\tt 1} & \bitbox{1}{\small{Play}} & \bitbox{1}{\small{Master}} & \bitbox{1}{\small{Sync}}
    \bitbox{1}{\small{On-Air}} & \bitbox{1}{\tt 1} & \bitbox{1}{\tt 0} & \bitbox{1}{\tt 0} \\
  \end{bytefield}
  \caption{CDJ state flag bits}
  \label{fig:cdjStateFlags}
\end{figure}

Byte~139, labeled $P_2$ seems to be another play state indicator,
having the value 122 ({\tt 0x7a}) when playing and 126 ({\tt 0x7e})
when stopped. When the CDJ is trying to play, but is being held in
place by the DJ holding down on the jog wheel, $P_1$ considers it to
be playing (value 3), while $P_2$ considers it to be stopped (value
126). Non-nexus players seem to use the value 106 ({\tt 0x6a}) when
playing and 110 ({\tt 0x6e}) when stopped, while nxs2 players use the
values 250 and 254 ({\tt 0xfa} and {\tt 0xfe}) so this seems to be
another bit field like $F$.

There are four different places where pitch information appears in
these packets: $Pitch_1$ at bytes~141--143, $Pitch_2$ at
bytes~153--155, $Pitch_3$ at bytes~193--195, and $Pitch_4$ at
bytes~197--199.

Each of these values represents a three-byte pitch adjustment
percentage, where {\tt 0x100000} represents no adjustment ($0\%$),
{\tt 0x000000} represents slowing all the way to a complete stop
($-100\%$, reachable only in Wide tempo mode), and {\tt 0x200000}
represents playing at double speed ($+100\%$).

Note that if playback is stopped by pushing the pitch fader all the
way to $-100\%$ in Wide mode, both $P_1$ and $P_2$ still show it as
playing, which is different than when the jog wheel is held down,
since $P_2$ shows a stop in the latter situation.

Here is how the pitch adjustment percentage represented by $Pitch_1$
would be calculated:

\begin{displaymath}
  100 \times
  \frac{(byte[141] \times 65536 + byte[142]  \times 256 + byte[143]) - 1048576}{1048576}
\end{displaymath}

We don't know why there are so many copies of the pitch information,
or all circumstances under which they might differ from each other,
but it seems that $Pitch_1$ and $Pitch_3$ report the current pitch
adjustment actually in effect (as reflected on the BPM display),
whether it is due to the local pitch fader, or a synced tempo master.

$Pitch_2$ and $Pitch_4$ are always tied to the position of the local
pitch fader, unless Tempo Reset is active, effectively locking the
pitch fader to 0\% and $Pitch_2$ and $Pitch_4$ to {\tt 0x100000}, or
the player is paused or the jog wheel is being held down, freezing
playback and locking the local pitch to $-100\%$, in which case they
both have the value {\tt 0x000000}.

When playback stops, either due to the play button being pressed or
the jog wheel held down, the value of $Pitch_4$ drops to {\tt
  0x000000} instantly, while the value of $Pitch_2$ drops over time,
reflecting the gradual slowdown of playback which is controlled by the
player's brake speed setting. When playback starts, again either due
to the play button being pressed or the jog wheel being released, both
$Pitch_2$ and $Pitch_4$ gradually rise to the target pitch, at a speed
controlled by the player's release speed setting.

If the player is \emph{not} synced, but the current pitch is different
than what the pitch fader would indicate (in other words, the player
is in the mode where it tells you to move the pitch fader to the
current BPM in order to change the pitch), moving the pitch fader
changes the values of $Pitch_2$ and $Pitch_4$ until they match
$Pitch_1$ and $Pitch_3$ and begin to affect the actual effective
pitch. From that point on, moving the pitch fader sets the value of
all of $Pitch_1$, $Pitch_2$, $Pitch_3$, and $Pitch_4$. This all seems
more complicated than it really needs to be...

The current BPM of the track (the BPM at the point that is currently
being played, or at the location where the player is currently paused)
can be found at bytes~146--147 (labeled $BPM$). It is a two-byte
integer representing one hundred times the current track BPM. So, the
current track BPM value to two decimal places can be calculated as:

\[ \frac{byte[146] \times 256 + byte[147]}{100} \]

In order to obtain the actual playing BPM (the value shown in the BPM
display), this value must be multiplied by the current effective
pitch, calculated from $Pitch_1$ as described above. Since calculating
the effective BPM reported by a CDJ is a common operation, here a
simplified equation that results in the effective BPM to two decimal
places, by combinining the $BPM$ and $Pitch1$ values:

\[ \frac{(b[146] \times 256 + b[147]) \times (b[141] \times 65536 + b[142]  \times 256 + b[143])}
     {104857600} \]

Because Rekordbox and the CDJs support tracks with variable BPM, this
value can and does change over the course of playing such tracks. When
no track is loaded, $BPM$ has the value {\tt 0xffff}.

The meaning of value $l_1$ (bytes~144--145) is not currently known. It
may simply reflect whether a track is loaded or not: it seems to have
the value {\tt 0x7fff} when no track is loaded, {\tt 0x8000} when a
rekordbox track is loaded, and {\tt 0x0000} when a non-rekordbox track
(like from a physical CD) is loaded.

Byte~157 (labeled $P_3$) seems to communicate additional information
about the current play mode, with the following meanings that we have
found so far:
\begin{description}
\item[0] No track is loaded.
\item[1] The player is paused or playing in Reverse mode.
\item[9] The player is playing in Forward mode with jog mode set to Vinyl.
\item[13] The player is playing in Forward mode with jog mode set to CDJ.
\end{description}

The 4-byte beat counter (which counts each beat from 1 through the end
of the track) is found in bytes~160--163, labeled $Beat$. When the
player is paused at the start of the track, this seems to hold the
value 0, even though it is beat 1, and when no rekordbox-analyzed
track is loaded, \emph{and in packets from non-nexus players}, this
holds the value {\tt 0xffffffff}.

The counter $B_b$ at byte~166 counts out the beat within each bar,
cycling $1\to2\to3\to4$ repeatedly, and can be used to identify the
down beat (as is used in the Master Player display on the CDJs as a
mixing aid). Again, when no reckordbox-analyzed track is loaded, this
holds the value~0. If you want to synchronize events to the down beat,
use the CDJ status packets' $F$ value to identify the master player,
but use the beat packets sent by that player (described in
Section~\ref{sec:beatPackets}) to determine when the beats are
actually happening.

A countdown timer to the next saved cue point is available in
bytes~164--165 (labeled $Cue$). If there is no saved cue point after
the current play location in the track, or if it is further than 64
bars ahead, these bytes contain the value {\tt 0x01ff} and the CDJ
displays ``-\,-.-~bars''. As soon as there are just 64 bars (256
beats) to go before the next cue point, this value becomes {\tt
  0x0100}. This is the point at which the CDJ starts to display a
countdown, which it displays as ``63.4~bars''. As each beat goes by,
this value decreases by 1, until the cue point is about to be reached,
at which point the value is {\tt 0x0001} and the CDJ displays
``00.1~bars''. On the beat on which the cue point was saved the value
is {\tt 0x0000} and the CDJ displays ``00.0~Bars''. On the next beat,
the value becomes determined by the next cue point (if any) in the
track.

Bytes~200-203 seem to contain a 4-byte packet counter labeled
$Packet$, which is incremented for each packet sent by the player. (I
am just guessing it is four bytes long, I have not yet watched long
enough for the count to need more than the last three bytes).

Byte~204, labeled $nx$, seems to have the value {\tt 0x0f} for nexus
players, and {\tt 0x05} for older players.

\subsection{Rekordbox Status Packets}

Rekordbox sends status packets which appear to be essentially
identical to those sent by a mixer, as shown in
Figure~\ref{fig:mixerStatus}, sending ``rekordbox'' as its device
name. The device number $D$ (bytes~33 and 36) seems to be 41 ({\tt
  0x29}), although it will probably use conflict resolution to pick an
unused number if multiple copies are running. The $F$ value we have
seen remains consistent as a status flag, showing {\tt 0xc0} which
would indicate that it is always ``playing'' but not synced, tempo
master, nor on the air. The $BPM$ value seems to track that of the
master player, and the same potential pitch values (fixed at {\tt
  0x100000}, or +0\%) are present, as is $X$. $B_b$ always seems to be
zero.

\section{Track Metadata}
\label{sec:metadata}

Thanks to
@EvanPurkhiser\footnote{\url{https://github.com/EvanPurkhiser}}, we
finally started making progress in retrieving metadata from CDJs, and
now some shared code from Austin
Wright\footnote{\url{https://bitbucket.org/awwright/libpdjl}} is
boosting our understanding considerably!

To be polite about it, the first step is to determine the port on
which the player is offering its remote database server. That can be
determined by opening a TCP connection to port $12,523$ on the player
and sending it sending a packet with the content shown in
Figure~\ref{fig:dbServerQueryPacket}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt]{16}
    \bitheader{0-15} \\

    \begin{leftwordgroup}{\tiny 0} % 0x00
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 0f} {\tt R} {\tt e} {\tt m} {\tt o}
        {\tt t} {\tt e} {\tt D} {\tt B} {\tt S} {\tt e} {\tt r} {\tt v}}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 16} % 0x10
      \bitboxes*{1}{{\tt e} {\tt r} {\tt 00}} & \bitbox[]{13}{}
    \end{leftwordgroup} \\
    
  \end{bytefield}
  \caption{DB Server query packet}
  \label{fig:dbServerQueryPacket}
\end{figure}

The player will send back a two-byte response, containing the high
byte of the port number followed by the low byte. So far, the response
from a CDJ has always indicated a port number of 1051, but using this
query to determine the port to use will protect you against any future
changes. The same query can also be sent to a laptop running rekordbox
to find the rekordbox database server port, which can also be queried
for metadata in the exact same way described below.

To find the metadata associated with a particular track, given its
rekordbox ID number, as well as the player and slot from which it was
loaded (all of which can be determined from a CDJ status packet
received by a virtual CDJ as described in
Section~\ref{sec:virtualCdj}), open a TCP connection to the device
from which the track was loaded, using the port that it gave you in
response to the DB Server query packet, then send the following four
packets.

The first packet sent to the database server contains the five bytes
{\tt 11 00 00 00 01}, and results in the same five bytes being sent
back.

All further packets have a shared structure. They consist of lists of
type-tagged fields (a type byte, followed by at least four value
bytes, although in the case of the variable-size types, those four
bytes are a big-endian integer that specifies the length of the
additional value bytes that make up the field). So far, there are four
known field types, and it turns out that the packet we just saw is one
of them, it represents the number 1.

\subsection{Field Types}

The first byte of a field identifies what type of field is coming. The
values {\tt 0x0f}, {\tt 0x10}, and {\tt 0x11} are followed by 1, 2,
and 4~byte fixed-length integer fields, while {\tt 0x14} and {\tt
  0x26} introduce variable-length fields, a binary blob and a UTF-16
big-endian string respectively.

\subsubsection{Number Fields}

Number fields are indicated by an initial byte {\tt 0x0f}, {\tt 0x10},
or {\tt 0x11} which is followed by big-endian integer value of length
1, 2, or 4~bytes respectively, as shown in Figure~\ref{fig:numFields}.
So, as noted above, the initial greeting packet sent to and received
back from the database server is a number field, four bytes long,
representing the value 1.

\begin{figure}
  \begin{center}
    \begin{bytefield}[bitwidth=2em]{2}
      \bitheader{0-1} \\
      \bitbox{1}{\tt 0f}\bitbox{1}{$n$} \\
    \end{bytefield}

    \begin{bytefield}[bitwidth=2em]{3}
      \bitheader{0-2} \\
      \bitbox{1}{\tt 10}\bitbox{2}{$n$} \\
    \end{bytefield}

    \begin{bytefield}[bitwidth=2em]{5}
      \bitheader{0-4} \\
      \bitbox{1}{\tt 11}\bitbox{4}{$n$} \\
    \end{bytefield}
  \end{center}
  \caption{Number Fields of length 1, 2, and 4}
  \label{fig:numFields}
\end{figure}


\subsubsection{Message Type Fields}

Message Type fields are very similar to Number fields, except they
begin with a {\tt 0x10} byte and seem only to be used as the third
field in a message, as described in
Section~\ref{sec:dbServerMessages}, to identify what kind of message
it is, and how many argument fields it contains. Once again the field
has four bytes following the type indicator, but in this case they are
subdivided. The first two bytes are a big-endian integer identifying
the message type. They are followed by a byte which always seems to be
{\tt 0x0f},

\subsection{Messages}
\label{sec:dbServerMessages}

Messages are introduced by a 4~byte Number field containing the magic
value {\tt 0x872349ae}. This is followed by another 4~byte number
field that contains a transaction ID, which starts at 1 and is
incremented for each query sent, and all messages sent in response to
that query will contain the same transaction ID. This is followed by a
2~byte number field containing the message type, a 1~byte number field
containing the number of argument fields present in the message, and a
blob field containing a series of bytes which identify the types of
each argument field. This blob is always 12~bytes long, regardless of
how few arguments there are (and presumably this means no message ever
has more than 12 arguments). Tag bytes past the actual argument count
of the message are set to 0.

The argument type tags use different values than the field type tags
themselves, for some reason, and it is not clear why this redundant
information is necessary at all, but that is true a number of places
in the protocol as you will see later. Here are the known tag values
and their meanings:

\begin{description}
\item[\tt 0x02] A string in UTF-16 big-endian encoding, with trailing
  NUL (zero) character.
\item[\tt 0x03] A binary blob.
\item[\tt 0x06] A 4~byte big-endian integer.
\end{description}

I am guessing that if we ever see them, a tag of 4 would represent a
1~byte integer, and 5 would represent a 2~byte integer. But so far no
such messages have been seen.

This header is followed by the fields that make up the message
arguments, if any. The header structure is illustrated in
Figure~\ref{fig:messageHeader}, where $TxID$ is the transaction ID,
$n$ is the number of arguments found in the message, and $t_1$ through
$t_{12}$ are the type tags for each argument, or 0 if there is no
argument in that position.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt]{16}
    \bitheader{0-15} \\

    \begin{leftwordgroup}{\tiny 0} % 0x00
      
      \bitbox{1}{\tt 11} & \bitbox{4}{\tt 872349ae} & \bitbox{1}{\tt 11} & \bitbox{4}{$TxID$} &
      \bitbox{1}{\tt 10} & \bitbox{2}{$type$} & \bitbox{1}{\tt 0f} & \bitbox{1}{$n$} &
      \bitbox{1}{\tt 14}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 16} % 0x10
      \bitbox{4}{{\tt 0000000c}\small{ (12)}} & \bitboxes*{1}{{$t_1$} {$t_2$} {$t_3$} {$t_4$}
        {$t_5$} {$t_6$} {$t_7$} {$t_8$} {$t_9$} {$t_{10}$} {$t_{11}$} {$t_{12}$}}
    \end{leftwordgroup} \\

  \end{bytefield}
  \caption{Message Header}
  \label{fig:messageHeader}
\end{figure}

Before you can send your first actual query, you need to send a
special message which seems to be necessary for establishing the
context for queries. It has a $type$ of 0, a special $TxID$ value of
{\tt 0xfffffffe}, and a single numeric argument, as shown in
Figure~\ref{fig:querySetupPacket}.

The value $D$ is, like in the other packets we have seen, a player
device number. In this case it is the device that is asking for
metadata information. It must be a valid player number between 1 and
4, and that player must actually be present on the network, must not
be the same player that you are contacting to request metadata from,
and must not be a player that has connected to that player via Link
and loaded a track from it. So the safest device number to use is the
device number you are using for your virtual CDJ, but since it must be
between 1 and 4, you can only do that if there are fewer than four
actual CDJs on the network.

TODO: Resume here, showing response packet, now that we understand its
structure.

The player responds with a 42 byte packet that starts with the message
separator and the message sequence number you sent. We have not yet
found any other meaningful information in this response.

At this point, the player is ready to accept queries.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt]{16}
    \bitheader{0-15} \\

    \begin{leftwordgroup}{\tiny 0} % 0x00

      \bitbox{1}{\tt 11} & \bitbox{4}{\tt 872349ae} & \bitbox{1}{\tt 11} & \bitbox{4}{\tt fffffffe} &
      \bitbox{1}{\tt 10} & \bitbox{2}{\tt 0000} & \bitbox{1}{\tt 0f} & \bitbox{1}{\tt 01} &
      \bitbox{1}{\tt 14}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 16} % 0x10
      \bitbox{4}{{\tt 0000000c}\small{ (12)}} & \bitboxes*{1}{{\tt 06} {\tt 00} {\tt 00} {\tt 00}
        {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 32} % 0x20
      \bitbox{1}{\tt 11} & \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {$D$}} & \bitbox[]{11}{}
    \end{leftwordgroup} \\
    
  \end{bytefield}
  \caption{Query context setup message}
  \label{fig:querySetupPacket}
\end{figure}


[ --- Skim and probably delete from here to end of section! --- ]

To ask for
metadata about a particular track, send a packet like the one shown in
Figure~\ref{fig:trackSetupPacket}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt]{16}
    \bitheader{0-15} \\

    \begin{leftwordgroup}{\tiny 0} % 0x00
      
      \bitboxes*{1}{{\tt 11} {\tt 87} {\tt 23} {\tt 49} {\tt ae} {\tt 11}} & \bitbox{4}{$seq$} &
      \bitboxes*{1}{{\tt 10} {\tt 20} {\tt 02} {\tt 0f} {\tt 02} {\tt 14}}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 16} % 0x10
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 0c} {\tt 06} {\tt 00} {\tt 00} {\tt 00}
        {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 32} % 0x20
      \bitbox{1}{\tt 11} & \bitbox{1}{$D$} & \bitbox{1}{\tt 01} & \bitbox{1}{$S_r$} & \bitboxes*{1}{{\tt 01} {\tt 11}} &
      \bitbox{4}{$rekordbox$} & \bitbox[]{6}{}
    \end{leftwordgroup} \\
    
  \end{bytefield}
  \caption{Track metadata query setup packet}
  \label{fig:trackSetupPacket}
\end{figure}

As described above, $seq$ should be 1 for the first query packet you
send, 2 for the next, and so on. $D$ should have the same value you
used in your initial query context setup packet, identifying the
device that is asking the question. $S_r$ is the slot in which the
track being asked about can be found, and has the same values used in
CDJ status packets, as shown in Figure~\ref{fig:cdjStatus}. Similarly,
$rekordbox$ identifies the local rekordbox database ID of the track
being asked about, as found in the CDJ status packet.

Once again the player responds with a 42 byte packet that starts with
the message separator and the message sequence number you sent, and
which contains no known useful information. But at this point there is
only one more message you need to send in order to get the metadata
response. That has the content shown in
Figure~\ref{fig:trackMetadataPacket}.

The value of $seq$ should be one higher than the one you sent in your
previous packet, while the values of $D$ and $S_r$ should be identical
to what you sent in it.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt]{16}
    \bitheader{0-15} \\

    \begin{leftwordgroup}{\tiny 0} % 0x00
      
      \bitboxes*{1}{{\tt 11} {\tt 87} {\tt 23} {\tt 49} {\tt ae} {\tt 11}} & \bitbox{4}{$seq$} &
      \bitboxes*{1}{{\tt 10} {\tt 30} {\tt 00} {\tt 0f} {\tt 06} {\tt 14}}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 16} % 0x10
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 0c} {\tt 06} {\tt 06} {\tt 06} {\tt 06}
        {\tt 06} {\tt 06} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 32} % 0x20
      \bitbox{1}{\tt 11} & \bitbox{1}{$D$} & \bitbox{1}{\tt 01} & \bitbox{1}{$S_r$} &
      \bitboxes*{1}{{\tt 01} {\tt 11} {\tt 00} {\tt 00}
        {\tt 00} {\tt 00} {\tt 11} {\tt 00} {\tt 00} {\tt 00} {\tt 0b} {\tt 11}}
    \end{leftwordgroup} \\

    \begin{leftwordgroup}{\tiny 48} % 0x30
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 11} {\tt 00} {\tt 00} {\tt 00}
        {\tt 0b} {\tt 11} {\tt 00} {\tt 00} {\tt 00} {\tt 00}} & \bitbox[]{2}{}
    \end{leftwordgroup} \\
    
  \end{bytefield}
  \caption{Track metadata query final packet}
  \label{fig:trackMetadataPacket}
\end{figure}

This will cause the player to send back a series of messages
containing the metadata fields describing the track you requested.
Each field will begin with the six-byte message separator sequence,
followed by the value of $seq$ you sent in the final metadata query
packet. Because this may be split across multiple packets, you should
keep reading until you see the final response field, which will have
the content shown in Figure~\ref{fig:finalMetadataField}.

The first two metadata response fields don't contain any values we
have yet figured out. Several contain string values. These are stored
as UTF-16 big-endian strings whose length is stored at bytes~42-45,
and where the string itself begins at byte~46. (The byte indices here
are counted from the start of the four-byte message sequence number
that follows the message separator, so the sequence number is found at
bytes~0-3.)

The string-containing fields are the third (track title), fourth
(artist), fifth (album), eighth (comment), ninth (musical key),
twelfth (genre), and thirteenth (label), although that has always been
blank so far. It may represent the color label assigned to a track,
and I just don't have tracks with that set.

The fifth field contains the track length in seconds, stored as a
four-byte integer at bytes~32-35.

In addition to containing the track title, the third field also
contains the track's artwork ID, as a 4-byte big-endian integer
starting 19~bytes before the end of the field.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt]{16}
    ~\\
    ~\\
    \bitheader{0-15} \\

    \begin{leftwordgroup}{\tiny 0} % 0x00
      
      \bitboxes*{1}{{\tt 11} {\tt 87} {\tt 23} {\tt 49} {\tt ae} {\tt 11}} & \bitbox{4}{$seq$} &
      \bitboxes*{1}{{\tt 10} {\tt 42} {\tt 01} {\tt 0f} {\tt 00} {\tt 14}}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 16} % 0x10
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 0c} {\tt 00} {\tt 00} {\tt 00} {\tt 00}
        {\tt 00} {\tt 00}{\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\
    
  \end{bytefield}
  \caption{Final track metadata response field}
  \label{fig:finalMetadataField}
\end{figure}

To request the artwork image corresponding to that ID, send a packet
like the one shown in Figure~\ref{fig:artworkRequestPacket}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt]{16}
    \bitheader{0-15} \\

    \begin{leftwordgroup}{\tiny 0} % 0x00
      
      \bitboxes*{1}{{\tt 11} {\tt 87} {\tt 23} {\tt 49} {\tt ae} {\tt 11}} & \bitbox{4}{$seq$} &
      \bitboxes*{1}{{\tt 10} {\tt 20} {\tt 03} {\tt 0f} {\tt 02} {\tt 14}}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 16} % 0x10
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 0c} {\tt 06} {\tt 06} {\tt 00} {\tt 00}
        {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00} {\tt 00}}
    \end{leftwordgroup} \\
    
    \begin{leftwordgroup}{\tiny 32} % 0x20
      \bitbox{1}{\tt 11} & \bitbox{1}{$D$} & \bitbox{1}{\tt 08} & \bitbox{1}{$S_r$} & \bitboxes*{1}{{\tt 01} {\tt 11}} &
      \bitbox{4}{$artwork$} & \bitbox[]{6}{}
    \end{leftwordgroup} \\
    
  \end{bytefield}
  \caption{Artwork query packet}
  \label{fig:artworkRequestPacket}
\end{figure}

As usual, $seq$ should be incremented each time you send a query, and
will be used to identify the response messages. $D$ should have the
same value you used in your initial query context setup packet,
identifying the device that is asking the question. $S_r$ is the slot
in which the track being asked about can be found, and has the same
values used in CDJ status packets, as shown in
Figure~\ref{fig:cdjStatus}. Finally, $artwork$ identifies the specific
artwork image you are requesting, as it was specified in the track
medatata response.

The response will be a single field, starting with the six-byte
message separator sequence followed by the sequence number you sent as
$seq$. The length in bytes of the image will be specified by a
four-byte big-endian integer starting at byte~48 of the response
field, and the image itself will be sent as the indicated number of
bytes immediately following the length (so starting at byte~52 of the
response).

\subsection{Background Research}

Prior to Evan's breakthrough, here is all we knew:

By setting up a managed switch to mirror traffic sent directly between
CDJs, we have been able to see how the Link Info operation is
implemented: The players open a direct TCP connection between each
other, and send queries to obtain the metadata about tracks with
particular rekordbox ID values.

Using an Ethernet switch
with port mirroring was, as we hoped, very helpful. As can be seen in
the capture at
\url{https://github.com/brunchboy/dysentery/raw/master/doc/assets/LinkInfo.pcapng},
which shows a CDJ with IP address 169.254.192.112 booting, the new CDJ
opens two TCP connections to the other CDJ at 169.254.119.181.

The first session (given id 0 by Wireshark), which begins at packet
206, connecting to port 12523, determines the port to use for metadata
queries.

The second TCP connection (Wireshark display filter {\tt tcp.stream eq
  1}), beginning at packet 212 and connecting to port 1051, shows the
track information used by the Link Info display passing between the
CDJs. You can see packets reflecting the initial display of a track
that was already loaded, then new information as the linked CDJ loaded
three other tracks.

There is another capture at
\url{https://github.com/brunchboy/dysentery/raw/master/doc/assets/LinkInfo2.pcapng},
with more Link Info streams to be studied (all of the odd numbered
{\tt tcp.stream} values in Wireshark are the relevant ones).

\section{What's Missing?}

We know this analysis isn't complete. There are some values we know
are available and useful (because CDJs and rekordbox itself show
them), but we have not figured out how to find them yet.

Before we discovered how to ask players for metadata about
particular tracks, we did some research into the underlying rexordbox
database. The database format is called
DeviceSQL,\footnote{\url{https://www.quora.com/What-database-system-did-Greg-Kemnitz-develop}}
and there used to be a free quick start suite for working with
it\footnote{\url{http://java.sys-con.com/node/328557}} but that site
no longer exists because the original (California) company
Encirq\footnote{\url{https://www.crunchbase.com/organization/encirq-corporation}}
was acquired by the Japanese Ubiquitous Corporation in
2008.\footnote{\url{http://www.ubiquitous.co.jp/en/news/press/pdf/p1730_01.pdf}}
It seems to still be
available,\footnote{\url{http://www.ubiquitous.co.jp/en/products/db/md/devicesql/}}
but I'd be surprised if they wanted to help out an open source effort
like this one.

\subsection{CDJ Packets to Rekordbox}

Performing a packet capture while rekordbox is running reveals that
the CDJs send unicast packets to the rekordbox address on port 50000,
in addition to the packets they normally broadcast on that port.
Figuring out how to pose as rekordbox might be useful in order to see
what additional data these can offer, although that may be much more
work than posing as a CDJ.

\subsection{Dysentery}

If you have access to Pioneer equipment and are willing to help us
validate this analysis, and perhaps even figure out more details, you
can find the tool that is being used to perform this research at: \\
\url{https://github.com/brunchboy/dysentery}

\begin{center}
  \begin{samepage}
    \includegraphics[width=4cm]{assets/DS-Logo-bw-4k}

    \vspace{0.25cm}
    \url{http://deepsymmetry.org}
  \end{samepage}
\end{center}

\end{document}

